# -*- coding: utf-8 -*-
"""
Created on Mon Jul 19 16:55:09 2021

@author: ndbke
"""


import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as optimize
import xarray as xr
import matplotlib.colors as colors

# ignore runtimewarnings generated by Newton's Method searching invalid areas
import warnings
warnings.filterwarnings("ignore", message="invalid value encountered in power")




### 1-variable constraint for Lagrange multiplier
def f_1v(beta,X,Xavg):
    
    num = 0
    denom = 0
    for i in range(len(X)):
        num += X[i] * beta**X[i]
        denom += beta**X[i]
        
    return num / denom - Xavg





### 1-variable entropy maximization
def max_1v(X,Xavg):
    
    # adapt range of guesses to the inputted value
    guesses = np.linspace(0.001,50,200)
    # explore for roots across guess space
    roots = optimize.newton(f_1v, x0=guesses, args=(X,Xavg),maxiter=1000,full_output=True)
    roots = clean_roots(roots)
    
    if roots.size == 0:
        print('no roots')
        return
    
    # get beta and alpha from root
    beta = -np.log(roots[0])
    alpha = np.log( np.sum( np.exp(-beta * X) ) )
    
    # get 
    p_arr_max = np.empty((len(X),1))
    for i in range(0,len(X)):
        p_arr_max[i] = np.exp( -alpha - beta * X[i] )
    p_arr_max /= np.sum(p_arr_max)
    
    return roots, beta, p_arr_max




### 2-variable entropy maximization
def max_2v(X,Xavg,Y,Yavg):
    
    # adapt range of guesses to the inputted value
    guesses = np.column_stack((np.linspace(0.001,50,200),np.linspace(0.001,50,200))).T
    # explore for roots across guess space
    roots_x = optimize.newton(f_1v, x0=guesses, args=(X,Xavg),maxiter=1000,full_output=True)
    roots_x = clean_roots(roots_x)
    roots_y = optimize.newton(f_1v, x0=guesses, args=(Y,Yavg),maxiter=1000,full_output=True)
    roots_y = clean_roots(roots_y)
    
    # define Lagrange multipliers
    beta = -np.log(roots_x)
    gamma = -np.log(roots_y)
    alpha = np.log( np.sum( np.exp(-beta * X) ) * np.sum( np.exp(-gamma * Y) ) )

    # get max-con-ent distribution
    p_arr = np.empty((len(Y),len(X)))
    for i in range(0,len(Y)):
        for j in range(0,len(X)):
            p_arr[i,j] = np.exp( -alpha - beta * X[j] - gamma * Y[i] )
    p_arr /= np.sum(p_arr)

    return [roots_x,roots_y], [alpha,beta,gamma], p_arr



### find actual roots output by Newton's Method
def clean_roots(roots_obj):
    
    # only roots for which alg converged
    roots = roots_obj.root[roots_obj.converged] 
    
    # remove NaNs
    roots = roots[~np.isnan(roots)] 

    # round off to remove tiny differences between what are actually same roots         
    roots = np.round(roots,5)                   
    
    # get unique values
    roots = np.unique(roots) 
                 
    return roots
    
    
    
### get averages from volumetric T-S plot
def tsv_dist(tsv):
    
    p_T = tsv.sum('s')
    p_S = tsv.sum('t')
    p_T /= np.sum(p_T)
    p_S /= np.sum(p_S)
    
    T_avg = np.average(tsv.t.values,weights=p_T)
    S_avg = np.average(tsv.s.values,weights=p_S)

    return T_avg, S_avg



#%% inputs

tsv_arc = xr.open_dataset('../NetCDFs/tsv_arc.nc', decode_times=False, autoclose=True)
T = tsv_arc.t.values
S = tsv_arc.s.values
T_avg, S_avg = tsv_dist(tsv_arc.volume)


X = S
Xavg = S_avg
Y = T
Yavg = T_avg



## test values
# X = np.linspace(-2,12,10)
# Xavg = 3
# Y = np.linspace(32,35,10)
# Yavg = 34



#%% UNIVARIATE TEST


# 1D maximization
xroot, xbeta, xpam = max_1v(X,Xavg)
yroot, ybeta, ypam = max_1v(Y,Yavg)
fx = f_1v(xroot,X,Xavg)
fy = f_1v(yroot,Y,Yavg)

# plot 1D constraints & roots
maxx = np.max([xroot,yroot])*1.1
xplot = np.linspace(0.001,maxx,100)
fplotx = f_1v(xplot,X,Xavg)
fploty = f_1v(xplot,Y,Yavg)
plt.figure()
plt.hlines(0,0,maxx,colors='green')
plt.plot(xplot,fplotx)
plt.scatter(xroot,fx)
plt.plot(xplot,fploty)
plt.scatter(yroot,fy)
plt.legend(["x","y"])


# plot 1D solutions
plt.figure()
plt.plot(X,xpam)
plt.figure()
plt.plot(Y,ypam)




#%% BIVARIATE TEST

# 2D maximization
roots, mults, p_arr = max_2v(X,Xavg,Y,Yavg)

# plot 2D solution in logscale colors
plt.figure()
plt.pcolormesh(X,Y,p_arr,shading="nearest",norm=colors.LogNorm())
plt.colorbar()
